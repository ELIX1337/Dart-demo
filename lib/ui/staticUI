БЕЗ ДИНАМИЧЕСКОГО UI

Хорошо, давайте рассмотрим пример кода для работы с двумя виджетами: 
Switch (включение/выключение) и Slider (регулировка яркости). 
Допустим, у нас есть устройство, которое поддерживает команды для управления включением/выключением 
и регулировкой яркости.

1. Измените `CommandWidget` для представления команд Switch и Slider:

class CommandWidget extends StatelessWidget {
  final String commandName;
  final Function(String) onCommandSelected;

  const CommandWidget({Key? key, required this.commandName, required this.onCommandSelected})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(commandName),
      onTap: () {
        // Вызываем колбэк с выбранной командой
        onCommandSelected(commandName);
      },
    );
  }
}

2. Измените главный экран для отображения Switch и Slider:

class MyHomePage extends StatelessWidget {
  final DeviceController deviceController;

  const MyHomePage({Key? key, required this.deviceController}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // Предположим, что у нас есть команды для включения/выключения и регулировки яркости
    var availableCommands = ['Включение/выключение', 'Регулировка яркости'];

    return Scaffold(
      appBar: AppBar(
        title: Text('Управление устройством'),
      ),
      body: ListView.builder(
        itemCount: availableCommands.length,
        itemBuilder: (context, index) {
          return CommandWidget(
            commandName: availableCommands[index],
            onCommandSelected: (selectedCommand) {
              // Вызываем метод управления устройством через ядро
              deviceController.executeCommand(selectedCommand);
            },
          );
        },
      ),
    );
  }
}

3. Обновите `DeviceController` для обработки команд Switch и Slider:

class DeviceController {
  final List<DeviceCommand> _commands;
  final List<Function(DeviceCommand)> _uiCallbacks = [];

  DeviceController(this._commands);

  // Метод для регистрации колбэка из внешнего слоя UI
  void registerUICallback(Function(DeviceCommand) callback) {
    _uiCallbacks.addAll(_commands); // Добавляем все команды сразу

    // Также вызываем этот колбэк для существующих команд
    _commands.forEach((command) => callback(command));
  }

  // Метод для выполнения команды
  void executeCommand(String commandName) {
    // Находим соответствующую команду по имени
    var selectedCommand = _commands.firstWhere((command) => command.name == commandName);

    // Выполняем команду
    selectedCommand.execute();

    // Вызываем все зарегистрированные колбэки для обновления UI
    _uiCallbacks.forEach((callback) => callback(selectedCommand));
  }

  // Другие методы для работы с устройством...

  // Метод для получения текущего состояния устройства (например, для отображения на Switch и Slider)
  Map<String, dynamic> getCurrentDeviceState() {
    // Предположим, что у нас есть метод в DeviceController для получения текущего состояния
    // Этот метод возвращает Map, где ключ - имя параметра, а значение - его текущее значение
    return {'power': true, 'brightness': 75};
  }
}

4. Создайте виджеты для отображения и управления состоянием устройства (например, `SwitchWidget` и `SliderWidget`):

class SwitchWidget extends StatelessWidget {
  final bool isOn;
  final Function(bool) onSwitchChanged;

  const SwitchWidget({Key? key, required this.isOn, required this.onSwitchChanged})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Switch(
      value: isOn,
      onChanged: (value) {
        // Вызываем колбэк при изменении состояния
        onSwitchChanged(value);
      },
    );
  }
}

class SliderWidget extends StatelessWidget {
  final double brightness;
  final Function(double) onBrightnessChanged;

  const SliderWidget({Key? key, required this.brightness, required this.onBrightnessChanged})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Slider(
      value: brightness,
      min: 0,
      max: 100,
      onChanged: (value) {
        // Вызываем колбэк при изменении значения яркости
        onBrightnessChanged(value);
      },
    );
  }
}

5. Обновите главный экран для отображения Switch и Slider:

class MyHomePage extends StatelessWidget {
  final DeviceController deviceController;

  const MyHomePage({Key? key, required this.deviceController}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // Получаем текущее состояние устройства
    var currentDeviceState = deviceController.getCurrentDeviceState();

    return Scaffold(
      appBar: AppBar(
        title: Text('Управление устройством'),
      ),
      body: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
         

 // Виджет для включения/выключения
          SwitchWidget(
            isOn: currentDeviceState['power'] as bool,
            onSwitchChanged: (value) {
              // Вызываем метод управления устройством для включения/выключения
              deviceController.executeCommand('Включение/выключение');
            },
          ),
          SizedBox(height: 16), // Просто для отступа между виджетами

          // Виджет для регулировки яркости
          SliderWidget(
            brightness: currentDeviceState['brightness'] as double,
            onBrightnessChanged: (value) {
              // Вызываем метод управления устройством для регулировки яркости
              deviceController.executeCommand('Регулировка яркости');
            },
          ),
        ],
      ),
    );
  }
}

Таким образом, мы создали виджеты SwitchWidget и SliderWidget, 
которые используются для управления состоянием устройства (включение/выключение и регулировка яркости). 
Используя ядро (DeviceController), мы обновляем UI при изменении состояния устройства, 
а также выполняем команды при взаимодействии с виджетами.